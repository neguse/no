## requirements to implement questions

* read one line from stdin
  * items are separated by space
* output to stdout
* make literal
* add, sub
* make function
* call function
  * recurse
* string insertion, deletion

## basic policy

* simple implementation
  * both questions and language processor

## specification

* operations, variables, system functions will be represented by single character
* single symbol will represents only single mean
* syntax tree generated by parser will be binary tree
* a program is array of expression
* output is value of evaluation of last expression

## types

* integer
* list
  * string is represented as list of integer

## operations

```
symbol (`p`arent or `l`eaf) : meaning

! (p) : assignment(definition)

~ (p) : call function
\ (p) : create function(lambda)
_ (l) : indicator of no arguments on function call
( (p) : begin of arguments on function call
, (l) : delimiter of arguments on function call
) (l) : end of arguments of function call
[ (p) : begin of arguments on function creation
. (l) : delimiter of arguments on function creation
] (l) : end of arguments of function creation

+ (p) : add
- (p) : sub
= (p) : equal
< (p) : less than
> (p) : greater than

? (p) : if
| (p) : then

# (p) : 2 digits hex

: (p) : cons

```

## system functions, constants

called by `~`

I : read
A : car
D : cdr
N : nil

## syntax

ebnf

```
program    = "{" { expression ";" } "}" ;
expression = assign_exp | call_exp | lambda_exp | op_exp | if_exp | hex2 | hex | variable ;
assign_exp = "!" variable expression ;
call_exp   = "~" expression arg_list ;
call_arg_list   = "(" { expression "," } ")" ;
lambda_exp = "\" lambda_arg_list expression ;
lambda_arg_list   = "[" { variable "." } "]" ;
op_exp     = op expression expression ;
op         = "+" | "-" | "<" | ">" | ":" ;
if_exp     = "?" expression "|" expression expression ;
hex2       = # hex hex ;
hex        = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "f" ;
variable   = alphabet
```

